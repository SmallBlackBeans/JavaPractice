[参考](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md)

## 概述
设计模式是解决问题的方案，学习现有的设计模式可以做到经验复用。

## 分类

### 一、创建型
#### 1. 单例
确保一个类只有一个实例，并提供该实例的全局访问点。
I 懒汉式-线程不安全
```java
public class Singleton {

    private static Singleton uniqueInstance;

    private Singleton() {
    }

    public static Singleton getUniqueInstance() {
        if (uniqueInstance == null) {
            uniqueInstance = new Singleton();
        }
        return uniqueInstance;
    }
}
```
II 饿汉式-线程安全  
```java
private static Singleton uniqueInstance = new Singleton();
```
III 懒汉式-加锁
```java
public static synchronized Singleton getInstance() {
    if (instance == null) {
        instance = new Singleton();
    }
    return instance;
}
```
IV 懒汉式-双重校验锁
```java
public class Singleton {

    private volatile static Singleton instance;

    private Singleton() {
    }

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
            // 如果不加下面这句，当多个线程都进到上面这个if中，执行顺序只是先后的问题，
            //第一个线程执行过初始化，第二个线程在执行的时候就不用赋值了
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

instance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分为三步执行：

1. 为 引用变量 instance 分配内存空间
2. new Singleton() 开辟内存空间
3. 将 instance 指向分配的内存地址

但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1>3>2。指令重排在单线程环境下不会出先问题，
但是在多线程环境下会导致一个线程获得还没有初始化的实例。
例如，线程 T1 执行了 1 和 3，此时 T2 调用 getInstance() 后发现 引用instance 不为空，
因此返回 instance，但此时 instance 还未被初始化。

使用 **volatile 可以禁止 JVM 的指令重排**，保证在多线程环境下也能正常运行。

V 静态内部类

这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持
```java
public class Singleton {

    //防止反射攻击
    private static boolean flag = false;

    private Singleton() {
        synchronized(ElvisModified.class) {           
            if(flag == false)  {
                flag = !flag;
            } else { 
                throw new RuntimeException("单例模式被侵犯！");  
            }
        }
    }

    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

VI 枚举实现
```java
public enum Singleton {
    INSTANCE;
    private String objName;
    public String getObjName() {
        return objName;
    }

    public void setObjName(String objName) {
        this.objName = objName;
    }
    public static void main(String[] args) {
        // 单例测试
        Singleton firstSingleton = Singleton.INSTANCE;
        firstSingleton.setObjName("firstName");
        Singleton secondSingleton = Singleton.INSTANCE;
        secondSingleton.setObjName("secondName");
        // 反射获取实例测试
        try {
            Singleton[] enumConstants = Singleton.class.getEnumConstants();
            for (Singleton enumConstant : enumConstants) {
                System.out.println(enumConstant.getObjName());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```
该实现在多次序列化再进行反序列化之后，不会得到多个实例，防止**序列化破坏单例模式**。
而其它实现需要使用 transient 修饰所有字段，并且实现序列化和反序列化的方法。

该实现可以防止**反射攻击**。
在其它实现中，通过 setAccessible() 方法可以将私有构造函数的访问级别设置为 public，
然后调用构造函数从而实例化对象，如果要防止这种攻击，需要在构造函数中添加防止多次实例化的代码。
该实现是由 JVM 保证只会实例化一次，因此不会出现上述的反射攻击。

#### 2. 简单工厂
在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。
```java
public class SimpleFactory {

    public Product createProduct(int type) {
        if (type == 1) {
            return new ConcreteProduct1();
        } else if (type == 2) {
            return new ConcreteProduct2();
        }
        return new ConcreteProduct();
    }
}
```

#### 3. 工厂方法(继承)
定义了一个创建对象的抽象工厂，由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。
```java
public interface Product {
}
public abstract class Factory {
    abstract public Product factoryMethod();
    public void doSomething() {
      //这里调用时获取的实例，是需要子类工厂去实现的。
      Product product = factoryMethod();
    }
}

public class ConcreteFactory extends Factory {
    public Product factoryMethod() {
        return new ConcreteProduct();
    }
}

public class ConcreteFactory1 extends Factory {
    public Product factoryMethod() {
        return new ConcreteProduct1();
    }
}
```

#### 4. 抽象工厂(组合)
提供一个接口，用于创建 相关的对象家族，  
即某一种类的产品，可能是一个总称，即又是一个抽象类AbstractProductA，AbstractProductB。

ConcreteFactory1，ConcreteFactory2 实现并创建了各自的具体产品。

#### 5. 生成器
封装一个对象的构造过程，并允许按步骤构造。  
* **StringBuilder**

理解：把构造过程都封装到具体类中，然后调用者使用的是其或者子类的方法，每个方法返回自己。  
链式调用？？？逐渐完善一个对象的所有属性。

#### 6. 原型模式(Prototype)
使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象。  

理解：将一个类对象具体形象化，当需要另一个同样的实例的时候，clone就可以得到一个同类型实例。

* **Object.clone()**

### 二、行为型
#### 7. 责任链
使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。
将这些对象连成一条链，并沿着这条链发送该请求，直到有一个对象处理它为止

类似于 iOS 中的消息处理，事件传递机制。

#### 8. 命令
将命令封装成对象中，具有以下作用：

* 使用命令来参数化其它对象
* 将命令放入队列中进行排队
* 将命令的操作记录到日志中
* 支持可撤销的操作

- Command：命令
- Receiver：命令接收者，也就是命令真正的执行者
- Invoker：通过它来调用命令

#### 9. 解释器
为语言创建解释器，通常由语言的语法和语法分析来定义.

理解：更多的用来对包装好的数据分解分析，校验，规范检查。

例如一颗解析树为 D And (A Or (B C))，文本 "D A" 满足该解析树定义的规则
```java
public abstract class Expression {
    public abstract boolean interpret(String str);
}
```

#### 10. 迭代器(Iterator)
提供一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示。

聚合类提供迭代器的创建，迭代器提供聚合数据的遍历。

#### 11. 中介者(Mediator)
集中相关对象之间复杂的沟通和控制方式。

理解：  
中介者持有相关的对象，每个对象事件的触发，调用中介者方法。  
中介者又定义不同的type，触发不同对象的事件。  
更像是中间穿插了一段临时代码，保证了不同对象间不会耦合。


##### Class Diagram(图)
- Mediator：中介者，定义一个接口用于与各同事（Colleague）对象通信。
- Colleague：同事，相关对象

#### 12. 备忘录(Memento)
在不违反封装的情况下获得对象的内部状态，从而在需要时可以将对象恢复到最初状态。  
java.io.Serializable

#### 13. 观察者(Observer)
定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。

主题（Subject）是被观察的对象，而其所有依赖者（Observer）称为观察者。

#### 14. 状态(State)
允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它所属的类。  
理解：  
内部包含了多种状态，行为中有临界条件的检测，同时切换不同的状态**(状态转移)**，进而具有不同状态下的行为能力。  
即行为触发状态转移。

** 状态是和行为关联，即不同的状态有各自的行为集合。** 

#### 15. 策略(Strategy)
定义一系列算法，封装每个算法，并使它们可以互换。

策略模式可以让算法独立于使用它的客户端。

状态模式主要是用来解决状态转移的问题，当状态发生转移了，那么 Context 对象就会改变它的行为；  

策略模式主要是用来封装一组可以互相替代的算法族，并且可以根据需要动态地去替换 Context 使用的算法

理解：  
策略更多的是通过切换不同的策略对象，让对象行为调用不同策略的算法实现。

** 可以具有相同的方法，但是具体实现不同，切换策略，即切换不同的算法实现。**

#### 16. 模板方法(Template Method)

定义算法框架，并将一些步骤的实现延迟到子类。

通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。

理解： 
多体现在抽象类中，调用步骤先写完，具体每一步，我可以管，也可以不管--子类管。


#### 17. 访问者(Visitor)
为一个对象结构（比如组合结构）增加新能力。

理解：  
对一个对象结构，传入一个访问者，这个访问者定义和实现了访问对象每一层结构的接口和方法。   

```java
class CustomerGroup {
    
    private List<Customer> customers = new ArrayList<>();

    void accept(Visitor visitor) {
        for (Customer customer : customers) {
            customer.accept(visitor);
        }
    }
}
 public class Customer implements Element {
 
     private String name;
     private List<Order> orders = new ArrayList<>();
 
     public void accept(Visitor visitor) {
         visitor.visit(this);
         for (Order order : orders) {
             order.accept(visitor);
         }
     }
 }
 public class Order implements Element {
 
     private String name;
     private List<Item> items = new ArrayList();
     
     public void accept(Visitor visitor) {
         visitor.visit(this);
 
         for (Item item : items) {
             item.accept(visitor);
         }
     }
 }
 public class Item implements Element {
     public void accept(Visitor visitor) {
         visitor.visit(this);
     }
 }
```
```java
public interface Visitor {
    void visit(Customer customer);

    void visit(Order order);

    void visit(Item item);
}
```
每一层的对象都要提供一个接口如accept，来接收这个visitor,  
调用accept,触发vistor.visit(对象)，表示我访问了这个对象。  
具体的访问统计或者反馈是在Visitor实现类里实现。
```java
public class VisitorImp implements Visitor {

    public void visit(Customer customer) {
        //xxxx
    }

    public void visit(Order order) {
        //xxxx
    }

    public void visit(Item item) {
        //xxxx
    }
}
```
 
#### 18. 空对象(Null)
使用什么都不做的空对象来代替 NULL。  
理解：  
对方法的空实现。


### 四、结构型

#### 19. 适配器
[参考](https://blog.csdn.net/zxt0601/article/details/52848004)  
把一个类接口转换成另一个用户需要的接口。适配器模式让那些接口不兼容的类可以一起工作。

理解：  
系统需要使用现有的类，但现有的类却不兼容。  
需要一个统一的输出接口，但是输入类型却不可预知。  

类适配器模式：通过继承 src类，实现 dst 类接口，完成src->dst的适配。  
对象适配器模式：持有 src类，实现 dst 类接口，完成src->dst的适配。  
接口适配器：
```java
        ValueAnimator valueAnimator = ValueAnimator.ofInt(0,100);
        valueAnimator.addListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationStart(Animator animation) {
                //xxxx具体实现
            }
        });
        valueAnimator.start();
```
AnimatorListenerAdapter 是一个抽象类，提供了AnimatorListener接口的方法默认实现，  
这里使用匿名内部类，继承了抽象类，重写了需要的个别方法。

#### 20. 桥接(Bridge)
将抽象与实现分离开来，使它们可以独立变化
#### 21. 组合

#### 22. 装饰

#### 23. 外观

#### 24. 享元

#### 25. 代理
控制对其它对象的访问。

